운영체제에서 실행중인 하나의 어플리케이션을 프로세스라고 부른다.
프로세스 : 할당된 메모리 공간을 기반으로 실행 중에 있는 프로그램을 가리켜 프로세스라고 한다.
간단히 말하면 실행중인 프로그램

쓰레드는 이러한 프로세스의 작업을 수행하는 단위이다.
쓰레드 : 프로세스 내에서 프로그램의 흐름을 형성하는 주체

Thread를 상속하는 클래스의 인스턴스를 가리켜 쓰레드라고 하지만 이는 잘못된 표현
쓰레드는 자바가상머신이 생성하는 것이기 때문.
start 메소드가 호출되면, 자바 가상 머신은 별도의 실행흐름을 형성하기 위한 여러가지 준비에 들어감 (메모리 공간을 할당)
이렇듯 별도의 실행 흐름을 형성하기 위해 자바가상머신에 의해 만들어지는 모든 리소스와 각종 정보들을 쓰레드라 한다.

쓰레드를 다루는 것의 목표 : 멀티 쓰레딩 (병렬 작업)

멀티 프로세스는 운영체제에서 할당받은 메모리를 가지고 독립적으로
실행하기 때문에 하나의 프로세스에서 오류가 발생해도 다른 프로세스에 직접적 영향을 미치지 않는다.
(독립적인 개체 2개를 실행한다고 생각하자.)

반면 멀티 쓰레드의 경우엔 한 프로세스에 2개 이상의 쓰레드를 내부에 가지고 실행 하기 때문에 쓰레드가 예외를
발생시킨다면 프로세스 자체가 종료 될 수 있다.

장점 : CPU 이용률 향상, 효율적인 자원 활용, 수행 기능별로 분리되므로 코드가 간결, 응답성의 향상
단점 : 같은 프로세스의 자원을 공유하므로 동기화 (syncronized) 필요, 동기화 처리에 관한 이슈 (교착, 기아상태) 처리 필요,
    CPU 환경이나 OS의 스케줄러 고려
    
멀티 쓰레딩을 위한 Thread의 생성법
- 메인 쓰레드는 무조건 존재하므로 메인 작업 외의 병렬 작업 수 만큼 작업 스레드를 생성.

1. Thread 클래스를 이용한 직접 생성
Thread 객체 생성 -
Thread th = new Thread(Runnable r);

Runnable 인터페이스를 구현하여 생성 -
class ThreadEx implements Runnable {
   @Override
   public void run() { // 쓰레드만의 메인메소드라고 생각하자
   //작업 코드
   }
}

Runnable 익명 구현 -
Thread th = new Thread(new Runnable()) {
   @Override
   public void run() {
   //작업 코드
   }
}

Run 메소드가 종료되면 쓰레드는 소멸

2. Thread 하위 클래스로 생성
Runnable을 따로 구현하지 않고 Thread 클래스를 상속 받아 작업 쓰레드를 정의하면서 내용을 포함시킨다.
Thread 클래스를 상속 후 run()메소드를 재정의하여 실행코드 작성

public void ThreadEx extends Thread {
   @Override
   public void run() {
   //작업 코드
   }
}

쓰레드 이름 지정하기 - Thread.setName("이름");
Thread t1 = new Thread(p, "생산자"); 처럼 객체를 생성하면서 지정

이름 알아오기 - Thread.getName();

Thread 스케줄링
주어진 시간 동안에 CPU에서 어떤 쓰레드를 동작하게 할지를 결정
1. 우선순위가 높은 쓰레드의 실행을 우선 (10~1 까지, 숫자가 클수록 우선순위가 높음)
2. 동일한 우선순위의 쓰레드가 둘 이상 존재할 때는 CPU 할당시간 분배해서 실행

우선순위(priority), 순환할당(Round-Robin) 방식 2가지가 존재함
우선순위 - 우선순위가 높은 쓰레드가 실행 상태 시간을 더 많이 가지도록 하여 작업하는 방식 : 코드를 통하여 제어
순환할당 - 시간 할당량을 정하여 쓰레드마다 정해진 시간만큼 작업시간을 주는 것 : JVM에서 자동으로 할당

getPriority() -> 메소드의 우선순위를 리턴

쓰레드의 상태
1. New 상태
쓰레드 클래스가 키워드 new를 통해서 인스턴스화 된 상태를 가리켜 New 상태라 한다.
가상머신에 의해 관리되는 것은 아닌 단계이다.

2. Runnable 상태
Start() 를 만나 호출되면 실행 준비 상태가 되는데 이를 Runnable 상태라 한다.
모든 실행 준비를 마치고 스케줄러에 의해서 선택되어 실행될 수 있기만 기다리는 상태
(바로 호출된다고 실행되는 것이 아니라 스케줄러에게 부름을 받아야 run 하는 것)

3. Blocked 상태
실행 중인  쓰레드가 sleep, join 메소드를 호출하거나 CPU 할당이 필요치 않는 입출력 연산을 하면
CPU를 다른 쓰레드에게 양보하고 자신은 Blocked 상태가 된다.
이 상태에서는 스케줄러에 선택을 받을 수 없어 실행될 수 없다.
다시 실행되려면 Blocked 상태가 된 원인이 제거가 되어 Runnable 상태로 돌아와야 된다.

4. Dead 상태
run 메소드의 실행이 완료되어서 run 메소드를 빠져 나오게 되면, 해당 쓰레드는 Dead 상태가 된다.
쓰레드의 실행을 위해서 할당 받았떤 메모리를 비롯해서 각종  쓰레드의 정보가 완전히 지워지는 상태이다.
Dead 상태가 된 쓰레드는 다시 Runnable 상태가 되지 못한다.

쓰레드 상태를 제어하기
1. 일시정지 - sleep()
sleep(long millis) - 밀리초 만큼 일시 정지, 1000밀리초 = 1초
일시정지 Blocked 상태가 됨

2. 작업취소 - interrupt()
진행 중인 쓰레드의 작업이 끝나기 전에 취소시킴

void interrupt() - 인터럽트 상태를 true로 변경
boolean isInterrupted() - 인터럽트 상태를 반환
static boolean interrupted() - 인터럽트 상태를 반환하고 인터럽트 상태를 false로 변경

3. 작업양보 - yield()
쓰레드가 자신에게 주어진 작업 시간을 다음 차례의 쓰레드에게 양보함
yield() 메소드를 수행하면 실행대기 상태가 됨, 응답성을 높이고 효율적인 실행을 위해 사용

4. 다른 쓰레드의 종료를 기다림 - join()
쓰레드가 작업을 잠시 멈추고 다른 쓰레드의 작업이 수행하도록 할 때 사용함
interrupt()에 의해 대기 상태에서 벗어날 수 있다.

join() - 다른 쓰레드의 작업을 마칠 때까지 일시 정지
join(long millis) - 다른 쓰레드의 작업 종료 또는 밀리초 만큼 일시 정지
join(long millis, int nanos) - 다른 쓰레드의 작업 종료 또는 밀리 + 나노초 만큼 일시정지

** 동기화
멀티 쓰레드 작업의 경우 여러 개의 쓰레드가 하나의 자원(객체)를 공유해서 작업하는 경우가 발생
-> 서로의 작업에 영향을 주게됨.

예를 들어 변수의 값에 1을 더해 반환하는 쓰레드 두개가 있다고 치자.
변수의 값은 99라서 1씩 증가되어 증가하는 쓰레드 두개가 실행되면
쓰레드1이 실행되면 100이 되고
쓰레드2가 실행되면 101이 된다고 예상할 수 있지만, 이는 이상적인 상황이다.

쓰레드1이 실행되어 1이 증가하고 그 값을 반환하는 과정에 쓰레드2가 실행될 수도 있는 것이다.
그렇게 되면 같은 값을 증가시키는 상황도 나올 수 있는 것이다.
그렇기 때문에 우리는 "쓰레드가 작업 중에 다른 쓰레드가 변수에 접근하지 못하도록 막아야 한다. 이것을 동기화라고 한다."

동기화 : 쓰레드가 사용중인 자원을 다른 쓰레드가 변경할 수 없도록 하려면 쓰레드 작업이 끝날 때 까지 객체에 잠금을 걸어 다른 쓰레드의 접근을 막음
단 하나의 쓰레드만 실행할 수 있는 코드 영역을 '임계영역'이라 지칭, 자바는 임계 영역에 대한 지원으로 동기화 메소드와 동기화 블록을 제공

동기화 메소드 : public synchronized void sum() {....}
동기화 블록 : synchronized(객체 참조변수) {....}

동기화 블록의 객체 참조 변수는 락을 걸고자하는 객체를 참조하는 것이여야함
동기화 메소드, 동기화 블록 모두 락을 얻고 반납화하는 과정이 자동임
임계 영역의 설정은 성능에 영향이 많음. 그러므로 임계 영역이 넓은 동기화 메소드보다는 동기화 블록을 이용하는 것이 맞다.

wait() - 락(자원을 기다리는 대기상태)을 반납 통지를 대기
notify() - 객체 대기 풀의 임의 스레드에게 통지
notifyAll() - 객체 대기 풀의 모든 스레드에 통지